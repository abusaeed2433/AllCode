{"id":916138351,"lang":"java","lang_name":"Java","time":"1Â week","timestamp":1678953896,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/916138351/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"N/A","code":"lass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        // Call the recursive function with full arrays and return the result\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\n    }\n    \n    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {\n        // Base case\n        if (inStart > inEnd || postStart > postEnd) {\n            return null;\n        }\n        \n        // Find the root node from the last element of postorder traversal\n        int rootVal = postorder[postEnd];\n        TreeNode root = new TreeNode(rootVal);\n        \n        // Find the index of the root node in inorder traversal\n        int rootIndex = 0;\n        for (int i = inStart; i <= inEnd; i++) {\n            if (inorder[i] == rootVal) {\n                rootIndex = i;\n                break;\n            }\n        }\n        \n        // Recursively build the left and right subtrees\n        int leftSize = rootIndex - inStart;\n        int rightSize = inEnd - rootIndex;\n        root.left = buildTree(inorder, inStart, rootIndex - 1, postorder, postStart, postStart + leftSize - 1);\n        root.right = buildTree(inorder, rootIndex + 1, inEnd, postorder, postEnd - rightSize, postEnd - 1);\n        \n        return root;\n    }\n}\n","compare_result":null,"title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal","has_notes":false}
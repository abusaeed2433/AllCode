{"id":919973056,"lang":"java","lang_name":"Java","time":"1 day, 3 hours","timestamp":1679469001,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/919973056/","is_pending":"Not Pending","title":"Minimum Score of a Path Between Two Cities","memory":"N/A","code":"class Solution {\n    private int[][] dist;\n    private int n,ans;\n    private boolean[] visited;\n    public int minScore(int n, int[][] roads) {\n        dist = new int[n][n];\n        this.n = n-1;\n        this.visited = new boolean[n];\n\n        for(int[] road : roads){\n            int a = road[0]-1;\n            int b = road[1]-1;\n            int d = road[2];\n            dist[a][b] = d;\n            dist[b][a] = d;\n        }\n\n        // for(int[] ds : dist){\n        //     for(int d : ds){\n        //         System.out.print(d+\" \");\n        //     }\n        //     System.out.println(\"\");\n        // }\n\n        ans = Integer.MAX_VALUE;\n        dfs(0,Integer.MAX_VALUE);\n        return ans;\n    }\n\n    private void dfs(int sIndex,int d){\n        if(sIndex == n){\n            ans = Math.min(ans,d);\n            visited[sIndex] = false;\n            return;\n        }\n        visited[sIndex] = true;\n        for(int i=0;i<=n;i++){\n            if(dist[sIndex][i] == 0 || visited[i]) continue;\n            d = Math.min(dist[sIndex][i],d);\n            dfs(i,d);\n        }\n        visited[sIndex] = false;\n    }\n\n}","compare_result":"11111111111111111111111111100000000000000","title_slug":"minimum-score-of-a-path-between-two-cities","has_notes":false}